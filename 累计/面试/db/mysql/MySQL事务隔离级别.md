## 事务
1. 数据库事务
简单来说：数据库事务可以保证多个对数据库的操作（也就是 SQL 语句）构成一个逻辑上的整体。构成这个逻辑上的整体的这些数据库操作遵循：要么全部执行成功,要么全部不执行 。
```sql
# 开启一个事务
START TRANSACTION;
# 多条SQL语句
SQL1,SQL2...
# 提交事务
COMMIT;
```
2. 何为ACID特性
    1. 原子性（Atomicity） ： 事务是最小的执行单位，不允许分割。事务的原子性确保动作要么全部完成，要么完全不起作用； 
    2. 一致性（Consistency）： 执行事务前后，数据保持一致，例如转账业务中，无论事务是否成功，转账者和收款人的总额应该是不变的；  
    3. 隔离性（Isolation）： 并发访问数据库时，一个用户的事务不被其他事务所干扰，各并发事务之间数据库是独立的；
    4. 持久性（Durability）： 一个事务被提交之后。它对数据库中数据的改变是持久的，即使数据库发生故障也不应该对其有任何影响。  
3. 并发事务带来那些问题  
    - 脏读(Dirty read):当一个事务正在访问数据并且对数据进行了修改，而这种修改还没有提交到数据库中，这时另外一个事务也访问了这个数据，然后使用了这个数据。因为这个数据是还没有提交的数据，那么另外一个事务读到的这个数据是“脏数据”，依据“脏数据”所做的操作可能是不正确的。
    - 丢失修改(Lost to modify): 指在一个事务读取一个数据时，另外一个事务也访问了该数据，那么在第一个事务中修改了这个数据后，第二个事务也修改了这个数据。这样第一个事务内的修改结果就被丢失，因此称为丢失修改。 例如：事务 1 读取某表中的数据 A=20，事务 2 也读取 A=20，事务 1 修改 A=A-1，事务 2 也修改 A=A-1，最终结果 A=19，事务 1 的修改被丢失。
    - 不可重复读（Unrepeatable read）: 指在一个事务内多次读同一数据。在这个事务还没有结束时，另一个事务也访问该数据。那么，在第一个事务中的两次读数据之间，由于第二个事务的修改导致第一个事务两次读取的数据可能不太一样。这就发生了在一个事务内两次读到的数据是不一样的情况，因此称为不可重复读。
    - 幻读(Phantom read):幻读与不可重复读类似。它发生在一个事务（T1）读取了几行数据，接着另一个并发事务（T2）插入了一些数据时。在随后的查询中，第一个事务（T1）就会发现多了一些原本不存在的记录，就好像发生了幻觉一样，所以称为幻读。  

    **不可重复读和幻读区别：**  
    不可重复的重点时修改比如多次读取读取一条记录发现其中某些列的值被修改，幻读的重点时在于新增或者删除比如多次读取一条记录发现记录增多或减少了。  
4. 事务隔离级别
    - READ-UNCOMMITTED(读取未提交)：最低的隔离级别，允许读取尚未提交的数据变更，可能会导致脏读、幻读或不可重复读。
    - READ-COMMITTED(读取已提交)：允许读取并发事务已经提交的数据，可以阻止脏读，但是幻读或不可重复读仍有可能发生。  
    - REPEATABLE-READ(可重复读)：对于同一个字段的多次读取结果都是一致的，除非数据是被本身事务所修改，可以阻止脏读和不可重复读，但幻读仍有可能发生。
    - SERIALIAZABLE(可串行化)：最高的隔离级别，完全服从ACID的隔离级别，所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰，也就是说，该级别可以防止脏读、不可重复读以及幻读。
5. MySQL的默认隔离级别是什么
    MySQL InnoDB 存储引擎的默认支持的隔离级别是 REPEATABLE-READ（可重读）。我们可以通过SELECT @@tx_isolation;命令来查看，MySQL 8.0 该命令改为SELECT @@transaction_isolation;
## 实际情况演示
下面使用2个命令行mysql，模拟多线程(多事务)对同一份数据的脏读问题。    
MySQL命令行的默认配置中事务都是自动提交的，即执行SQL语句后就会马上执行COMMIT操作。如果要显示地开启一个事务需要使用命令:START TRANSACTION。   
我们可以通过下面的命令来设置隔离级别。   
```sql
SET [SESSION|GLOBAL] TRANSACTION ISOLATION LEVEL [READ UNCOMMITTED|READ COMMITTED|REPEATABLE READ|SERIALIZABLE]

```   
我们再来看一下我们在下面实际操作中使用到的一些并发控制语句：    
- START TRANSACTION | GEGIN：显式地开启一个事务。   
- COMMIT：提交事务，使得对数据库做的所有修改成为永久性。   
- ROLLBAK:回滚会结束永辉的事务，并撤销正在进行的所有未提交的修改。   

### 脏读(读未提交)
![](./img_db/%E8%84%8F%E8%AF%BB%E6%A1%88%E4%BE%8B.PNG)
### 避免脏读(读已提交)
![](./img_db/%E9%81%BF%E5%85%8D%E8%84%8F%E8%AF%BB.PNG)
### 不可重复读
还是刚才上面的读已提交的图，虽然避免了读未提交，但是却出现了，一个事务还没有结束，就发生了不可重复读问题。
![](./img_db/%E4%B8%8D%E5%8F%AF%E9%87%8D%E5%A4%8D%E8%AF%BB.PNG)
### 可重复读
![](./img_db/%E5%8F%AF%E9%87%8D%E5%A4%8D%E8%AF%BB.PNG)
### 防止幻读(可重复读)
![](./img_db/%E9%98%B2%E6%AD%A2%E5%B9%BB%E8%AF%BB.PNG)
一个事务对数据库进行操作，这种操作的范围是数据库的全部行，然后第二个事务也在对这个数据库操作，这种操作可以是插入一行记录或删除一行记录，那么第一个是事务就会觉得自己出现了幻觉，怎么还有没有处理的记录呢? 或者 怎么多处理了一行记录呢?

幻读和不可重复读有些相似之处 ，但是不可重复读的重点是修改，幻读的重点在于新增或者删除。